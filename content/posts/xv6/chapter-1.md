---
title: "xv6 教材笔记 - 1. Operating system interfaces"
hideSummary: true
date: 2024-07-28T12:37:07+08:00
draft: true
tags: ["xv6", "MIT 6.s081"]
series: ["xv6", "MIT 6.s081"]
author: ["xubinh"]
type: posts
math: false
---

- xv6 借鉴了 Unix 的基本接口和内部实现.
- Unix 的接口十分精简, 但机制设计得很好, 能够组合出丰富的功能. 其他后继者如 BSD, Linux, macOS, Solaris, 甚至 Windows 都能从中看到 Unix 的影子.
- xv6 使用了传统的**内核** (kernel) 的形式, 内核是一个特殊的程序, 用于运行其他程序, 并为其他程序提供系统服务.
- 当一个程序需要使用系统服务时, 它需要执行**系统调用** (system call), 系统调用将进入内核, 执行服务, 然后从内核返回. 因此程序在**用户空间** (user space) 和**内核空间** (kernel space) 之间交替执行.
- 内核使用了由 CPU 提供的一种硬件保护机制来确保每个用户程序只能访问它们各自的内存空间. 内核自身则拥有特权 (privilege), 不收硬件保护机制的限制. 当用户程序请求系统调用时, 用户程序的特权等级将被提升以便执行内核中的预先编排好的系统程序.
- 内核所提供的系统调用就是用户程序所看到的一个操作系统暴露出的接口. xv6 提供了经典 Unix 系统所提供的服务和系统调用的一个子集.
- 相对于内核, **shell** 是一个代表用户与操作系统进行交互的命令行接口. shell 本质上就是一个普通的用户程序, 它读取用户输入的命令, 然后通过执行合适的系统调用来实现这些命令. 也正是由于 shell 与一般用户程序无异, 用户能够很容易地在不同的 shell 实现之间进行更换.
- xv6 实现的 shell 模仿的是 Unix Bourne shell (即 sh).

## 1.1 Processes and memory

- 一个进程可以使用系统调用 `fork` 创建一个新的子进程. 子进程拥有和父进程一模一样的内存映像 (只是看上去一样, 实际上是两个物理地址不同的副本). `fork` 子进程的 PID, 在子进程中为零.
  - 函数签名: `int fork()`
- 系统调用 `exit` 将会使得调用进程停止运行并释放所有资源. `exit` 接受一个整型参数表示退出状态 (exit status), 一般使用 0 表示成功, 使用 1 表示失败.
  - 函数签名: `int exit(int status)`
- 系统调用 `wait` 一般由一个父进程调用, 其返回值为一个由 `exit` 停止的 (或手动被 kill 掉的) 子进程的 PID, 并将子进程的退出状态复制到传入的地址中. 如果没有子进程退出, 那么 `wait` 将一直阻塞下去. 如果父进程没有任何子进程, 那么 `wait` 将立即返回 -1. 传入的地址可以是零指针, 表示父进程不关心子进程的退出状态.
  - 函数签名: `int wait(int *status)`
- 系统调用 `exec` 使用硬盘上的某个文件中所存储的内存映像 (memory image) 替换当前正在执行的程序的内存映像. 这个文件必须具有某种可解释的格式以指明哪些内容是指令, 哪些又是数据. xv6 使用的格式为 ELF 格式. 一般情况下这种文件是程序员通过编译一个程序的源文件得到的. `exec` 并不会返回, 而是顺着 ELF 文件中指明的程序起始地址在新程序中继续执行下去. `exec` 接受两个参数, 第一个是所要执行的可执行文件的名称, 第二个是存储着所要传入的字符串参数的数组.
  - 函数签名: `int exec(char *file, char *argv[])`
- xv6 shell 就是通过使用 `exec` 系统调用实现代替用户执行程序的功能的. xv6 shell 程序的主要逻辑是一个 loop 循环, 每次循环都先读取用户的输入, 然后调用 `fork` 创建子进程, 子进程将负责调用 `exec` 执行用户想要执行的程序, 而父进程负责调用 `wait` 等待子进程退出.
  - 初看上去似乎 `fork` 和 `exec` 完全可以合并为一个单独的系统调用, 但此后将会了解到 shell 在实现它的 I/O 重定向功能时正是利用了 `fork` 和 `exec` 的分离设计.
  - 为了避免 `fork` 出一个子进程并分配好所有内存之后又立即调用 `exec` 使用另一个程序的内存映像将其替换掉带来的巨大浪费, 内核使用一种称为**写时复制** (copy-on-write) 的虚拟内存技术来优化 `fork` 的实现.
- 系统调用 `sbrk` 用于程序 (例如 `malloc`) 在运行时动态向系统申请内存. `sbrk` 接受一个整型参数, 表示要申请的字节数. 其返回值为所申请内存块的起始地址.
  - 函数签名: `char *sbrk(int n)`
