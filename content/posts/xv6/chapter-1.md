---
title: "xv6 教材笔记 - 1. Operating system interfaces"
hideSummary: true
date: 2024-07-28T12:37:07+08:00
draft: true
tags: ["xv6", "MIT 6.s081"]
series: ["xv6", "MIT 6.s081"]
author: ["xubinh"]
type: posts
math: false
---

- xv6 借鉴了 Unix 的基本接口和内部实现.
- Unix 的接口十分精简, 但机制设计得很好, 能够组合出丰富的功能. 其他后继者如 BSD, Linux, macOS, Solaris, 甚至 Windows 都能从中看到 Unix 的影子.
- xv6 使用了传统的**内核** (kernel) 的形式, 内核是一个特殊的程序, 用于运行其他程序, 并为其他程序提供系统服务.
- 当一个程序需要使用系统服务时, 它需要执行**系统调用** (system call), 系统调用将进入内核, 执行服务, 然后从内核返回. 因此程序在**用户空间** (user space) 和**内核空间** (kernel space) 之间交替执行.
- 内核使用了由 CPU 提供的一种硬件保护机制来确保每个用户程序只能访问它们各自的内存空间. 内核自身则拥有特权 (privilege), 不收硬件保护机制的限制. 当用户程序请求系统调用时, 用户程序的特权等级将被提升以便执行内核中的预先编排好的系统程序.
- 内核所提供的系统调用就是用户程序所看到的一个操作系统暴露出的接口. xv6 提供了经典 Unix 系统所提供的服务和系统调用的一个子集.
- 相对于内核, **shell** 是一个代表用户与操作系统进行交互的命令行接口. shell 本质上就是一个普通的用户程序, 它读取用户输入的命令, 然后通过执行合适的系统调用来实现这些命令. 也正是由于 shell 与一般用户程序无异, 用户能够很容易地在不同的 shell 实现之间进行更换.
- xv6 实现的 shell 模仿的是 Unix Bourne shell (即 sh).

## 1.1 Processes and memory

- 一个进程可以使用系统调用 `fork` 创建一个新的子进程. 子进程拥有和父进程一模一样的内存映像 (只是看上去一样, 实际上是两个物理地址不同的副本). `fork` 子进程的 PID, 在子进程中为零.
  - 函数签名: `int fork()`
- 系统调用 `exit` 将会使得调用进程停止运行并释放所有资源. `exit` 接受一个整型参数表示退出状态 (exit status), 一般使用 0 表示成功, 使用 1 表示失败.
  - 函数签名: `int exit(int status)`
- 系统调用 `wait` 一般由一个父进程调用, 其返回值为一个由 `exit` 停止的 (或手动被 kill 掉的) 子进程的 PID, 并将子进程的退出状态复制到传入的地址中. 如果没有子进程退出, 那么 `wait` 将一直阻塞下去. 如果父进程没有任何子进程, 那么 `wait` 将立即返回 -1. 传入的地址可以是零指针, 表示父进程不关心子进程的退出状态.
